**13.3 生命周期（Lifetimes）**
-------------
生命周期可以通俗地理解为保证A的依赖B，比A活的更长。这样就可以保证不会悬空指针的问题，保证内存的安全。

先看下面例子：
```rust
fn dangling() -> &i32 {
    let x: i32 = 100;
    &x
}

fn foo() {
	let m: &i32 = dangling();
	println!("{}", m);
}
	
fn main() {
	foo();
}
```
编译：
> error: missing lifetime specifier [E0106]
fn dangling() -> &i32 {
　　　　　　^
 
当然上面的例子无法编译成功的。函数返回了一个局部变量x的引用，x在函数返回后被释放销毁，继而会出现“悬空指针”的问题。
上例隐含了“生命周期”的命名，Rust自动推导daling为：
```rust
fn dangling<'a>() -> &'a i32 {
    let x: i32 = 100;
    &x
}
```
'a为读作生命周期a，<>内为生命周期的声明，可用字母a-z定义。
例如：
```rust
fn foo<'a, 'b, 'c>(x: &'a i32, y: &'b i32, z: &'c i32) -> &'a i32 {
	x
}
```

如果不显示生命foo中的生命周期，Rust编译器无法推导出返回值应该存活多久。

####**生命周期推导**

在生命周期之前的章节，我们见到的例子中几乎没有显示声明生命周期的情况，这种情形称之为“省略生命周期（Lifetime Elision）”，由Rust在编译阶段自动推导输入参数以及输出参数（返回值）的生命周期。

“省略生命周期”的自动推导符合以下规则。
> 备注：
> 　　输入生命周期：函数引用类型参数。
> 　　输出生命周期：为引用类型的函数返回值。
#####**1. 每一个被省略的函数参数推导为不同生命周期参数**
```rust
fn foo(x: &i32, y: &i32, z: &i32) {}
```
推导为：
```rust
fn foo<'a, 'b, 'c>(x: &'a i32, y: &'b i32, z: &'c i32) {}
```

#####**2. 只有引用类型的参数才会被推导**
```rust
fn foo(x: i32, y: &i32) {}
```
推导为：
```rust
fn foo<'a>(x: i32, y: &'a i32) {}
```

#####**3. 如果有且仅有一个输入生命周期，这个生命周期被赋予所有函数返回值中被省略的生命周期。**
```rust
fn foo(x: &i32, y: i32) -> &i32 { //注意：y不属于引用类型。
	x
}
```
推导为：
```rust
fn foo<'a>(x: &'a i32, y: i32) -> &'a i32 {
	x
}
```

多个输入生命周期，编译器无法确定返回值该依赖哪一个输入生命周期：
```rust
fn foo(x: &i32, y: &i32) -> &i32 {
	x
}
```
编译报错：
>error: missing lifetime specifier [E0106]
fn xfoo(x: &i32, y: &i32) -> &i32 {
　　　　　　　　　　　^~~~
输入参数分别推导为'a和'b，但是无法确定返回值该依赖哪一个生命周期。


#####**4. 在存在多个输入生命周期的情况下，如果有一个参数为&self或&mut self，则所有返回值的省略生命周期均为self的生命周期**
```rust
struct A {
    x: i32,
}

impl A {
	fn foo(&self) -> &i32 {
		&self.x
	}
}

fn main() {}
```
其中foo自动推导为：
```rust
fn foo<'a>(&'a self) -> &'a i32 {
		&self.x
}
```

####**总结**
一般来讲，可以通过Scope作用域来理解生命周期，“生命周期”在编译阶段就已经决定变量应该在什么时候销毁内存该什么时候释放，没有运行时的内存管理（GC）开销，完美结合了运行效率和内存安全的双重优点。
